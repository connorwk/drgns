/*
 * I2C_SSD1306.c
 *
 *  Created on: Jan 14, 2019
 *      Author: win7 vm
 */

#include "F28x_Project.h"

//Uint16 MsgBuffer[15];    // Message buffer, FIFO max size is only 16, but the first transmission is for Co and D/C, so our limit is 15.
//Uint16 MsgStatus;  // Message status, 0x0000 ready to send, 0x000F waiting for stop, 0x00FF error.
const unsigned char I2C_Display_Font[96][5] = {
    0x00, 0x00, 0x00, 0x00, 0x00, //
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x56, 0x20, 0x50, // &
    0x00, 0x08, 0x07, 0x03, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x40, 0x38, 0x18, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x00, 0x60, 0x60, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x49, 0x4D, 0x33, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x41, 0x21, 0x11, 0x09, 0x07, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x00, 0x14, 0x00, 0x00, // :
    0x00, 0x00, 0x40, 0x34, 0x00, // ;
    0x00, 0x08, 0x14, 0x22, 0x41, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x00, 0x41, 0x22, 0x14, 0x08, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x3E, 0x41, 0x5D, 0x59, 0x4E, // @
    0x7C, 0x12, 0x11, 0x12, 0x7C, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x41, 0x3E, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x09, 0x01, // F
    0x3E, 0x41, 0x49, 0x49, 0x7A, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x1C, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x26, 0x49, 0x49, 0x49, 0x32, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x3F, 0x40, 0x38, 0x40, 0x3F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x03, 0x04, 0x78, 0x04, 0x03, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x7F, 0x41, 0x41, 0x41, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // '\'
    0x00, 0x41, 0x41, 0x41, 0x7F, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x80, 0x80, 0x80, 0x80, 0x80, // _
    0x00, 0x03, 0x07, 0x08, 0x00, // '
    0x20, 0x54, 0x54, 0x54, 0x78, // a
    0x7F, 0x28, 0x44, 0x44, 0x38, // b
    0x38, 0x44, 0x44, 0x44, 0x28, // c
    0x38, 0x44, 0x44, 0x28, 0x7F, // d
    0x38, 0x54, 0x54, 0x54, 0x18, // e
    0x00, 0x08, 0x7E, 0x09, 0x02, // f
    0x18, 0xA4, 0xA4, 0xA4, 0x7C, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, // i
    0x00, 0x20, 0x40, 0x40, 0x3D, // j
    0x00, 0x7F, 0x10, 0x28, 0x44, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, // l
    0x7C, 0x04, 0x78, 0x04, 0x78, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, // n
    0x38, 0x44, 0x44, 0x44, 0x38, // o
    0xFC, 0x18, 0x24, 0x24, 0x18, // p
    0x18, 0x24, 0x24, 0x18, 0xFC, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, // r
    0x48, 0x54, 0x54, 0x54, 0x24, // s
    0x04, 0x04, 0x3F, 0x44, 0x24, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w
    0x44, 0x28, 0x10, 0x28, 0x44, // x
    0x4C, 0x90, 0x90, 0x90, 0x7C, // y
    0x44, 0x64, 0x54, 0x4C, 0x44, // z
    0x00, 0x08, 0x36, 0x41, 0x00, // {
    0x00, 0x00, 0x77, 0x00, 0x00, // |
    0x00, 0x41, 0x36, 0x08, 0x00, // }
    0x02, 0x01, 0x02, 0x04, 0x02, // ~
    0x00, 0x06, 0x09, 0x09, 0x06  // degrees
};


//
// I2CA_Init - Initialize I2CA settings
//
void I2C_Init(void)
{
    //I2caRegs.I2CSAR.all = 0x003C;     // Slave address - SSD1306 Address (Could also be 0x003D if SA0 on the device is set)
    I2caRegs.I2CMDR.bit.IRS = 0;

    I2caRegs.I2CPSC.all = 16;         // Prescaler - need 7-12 Mhz on module clk
    I2caRegs.I2CCLKL = 130;            // NOTE: must be non zero
    I2caRegs.I2CCLKH = 130;             // NOTE: must be non zero

    I2caRegs.I2CMDR.all = 0x0020;     // Take I2C out of reset
                                      // Stop I2C when suspended
    //I2caRegs.I2CIER.all = 0x20;       // Enable SCD __interrupts

    I2caRegs.I2CFFTX.all = 0x6000;    // Enable FIFO mode and TXFIFO and reset.
    I2caRegs.I2CFFRX.all = 0x2040;    // Enable/Reset RXFIFO, clear RXFFINT
    //MsgStatus = 0x0000;
    return;
}


//
// I2CA_WriteData - Transmit I2CA message
//
Uint16 I2C_WriteData(Uint16 datacommand, const unsigned char* message, Uint16 length)
{
    I2caRegs.I2CSAR.all = 0x003C; // 0x3C address 7 bit
    // wait for STOP condition
    while (I2caRegs.I2CMDR.bit.STP != 0);

    //MsgStatus = 0x000F; // Set message status.

    I2caRegs.I2CCNT = length + 1;

    //
    // Put message in FIFO.
    //
    // Set datacommand bit in first "Control Byte".
    I2caRegs.I2CDXR.all = datacommand << 6;
    while (length--) I2caRegs.I2CDXR.all = *message++;

    //
    // Send start as master transmitter
    //
    I2caRegs.I2CMDR.all = 0x6E20; // Free, Start, Stop, Master, Transmitter, Reset

    return 0x0000;
}

void I2C_Display_Char(char character)
{
    static unsigned char c = 0x00;
    I2C_WriteData(1, I2C_Display_Font[character-32], 5);
    I2C_WriteData(1, &c, 1);
}

// Display string to display, 21 characters per row, 4 rows
// String should be 21 characters or less.
// x = 0>20 y =  0>3
void I2C_Display_String(char* string, Uint16 x, Uint16 y)
{
    unsigned char c;
    if ( x > 20 || y > 3 )
    {
        return;
    }

    c = 0x0000 + (0x000F & (x*6));
    I2C_WriteData(0, &c, 1);      // Set Lower Column Start Address
    c = 0x0010 + ((0x00F0 & (x*6)) >> 4);
    I2C_WriteData(0, &c, 1);      // Set Higher Column Start Address
    c = 0x00B0 + y;
    I2C_WriteData(0, &c, 1);      // Set GDDRAM Page Start Address

    while( c = *string++) I2C_Display_Char(c);
}

const unsigned char I2C_Display_Init_Values[] = {
    // First byte is length, last 3 are command/data.
    0x01,0xAE,0x00,0x00, // Reset Display.
    0x02,0xD5,0x80,0x00, // Set Display Clock Divide Ratio / OSC Frequency
    0x02,0xA8,0x1F,0x00, // Set Multiplex Ratio for 128x32 (32-1)
    0x02,0xD3,0x00,0x00, // Set Display Offset 48-1 2F
    0x01,0x40,0x00,0x00, // Set Display Start Line
    0x02,0x8D,0x14,0x00, // Set Charge Pump (0x10 External, 0x14 Internal DC/DC)
    0x02,0x20,0x02,0x00, // Set Horizontal Addressing mode.
    0x01,0xA1,0x00,0x00, // Set Segment Re-Map
    0x01,0xC8,0x00,0x00, // Set Com Output Scan Direction
    0x02,0xDA,0x02,0x00, // Set COM Hardware Configuration
    0x02,0x81,0xCF,0x00, // Set Contrast
    0x02,0xD9,0xF1,0x00, // Set Pre-Charge Period (0x22 External, 0xF1 Internal)
    0x02,0xDB,0x40,0x00, // Set VCOMH Deselect Level 0x20?
    0x01,0xA4,0x00,0x00, // Set all pixels OFF
    0x01,0xA6,0x00,0x00, // Set display not inverted
    0x01,0xAF,0x00,0x00, // Set display On
    0x01,0x00,0x00,0x00, // Set Lower Column Start Address
    0x01,0x10,0x00,0x00, // Set Higher Column Start Address
    0x01,0xB0,0x00,0x00, // Set GDDRAM Page Start Address
    0x00,0x00,0x00,0x00
};

void I2C_Display_Init(void)
{
    const unsigned char *b = I2C_Display_Init_Values;
    while(*b) I2C_WriteData(0, b + 1, *b), b += 4;
    //MsgBuffer[0] = 0x0021;
    //MsgBuffer[1] = 0x0000;
    //MsgBuffer[2] = 0x007F;
    //I2C_WriteData(0, MsgBuffer, 3);      // Setup Column start and end address
    //MsgBuffer[0] = 0x0022;
    //MsgBuffer[1] = 0x0000;
    //MsgBuffer[2] = 0x0003;
    //I2C_WriteData(0, MsgBuffer, 3);      // Setup Page start and end address
    // Clear display.
    I2C_Display_String("                      ", 0, 0);
    I2C_Display_String("                      ", 0, 1);
    I2C_Display_String("                      ", 0, 2);
    I2C_Display_String("                      ", 0, 3);
    return;
}
